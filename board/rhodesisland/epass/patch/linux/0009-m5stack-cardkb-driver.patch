--- a/drivers/staging/shirogane/cardkb.c
+++ b/drivers/staging/shirogane/cardkb.c
@@ -0,0 +1,439 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for keys on M5Stack Unit CardKB
+ *
+ * Copyright (C) 2026 Shirgane Tsumugi
+ *
+ * Author : Shirgane Tsumugi
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/of.h>
+
+#if 0
+    #define SRGN_PRINTK(fmt, ...) printk(KERN_INFO "srgn:" fmt, ##__VA_ARGS__)
+#else
+    #define SRGN_PRINTK(fmt, ...)
+#endif
+
+struct cardkb_data {
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct delayed_work dwork;
+
+    int polling_interval;
+    u8 last_code;
+};
+
+#define CARDKB_MODIFIER_CTRL 0x01
+#define CARDKB_MODIFIER_SHIFT 0x02
+
+struct cardkb_map_entry {
+    u8 code;
+    u8 keycode;
+    u8 modifier;
+};
+
+//cardkb to english_us keyboard
+const static struct cardkb_map_entry cardkb_map[] = {
+    {0x1B, KEY_ESC, 0},
+    {0x08, KEY_BACKSPACE, 0},
+    {0x09, KEY_TAB, 0},
+    {0x0D, KEY_ENTER, 0},
+    {0x20, KEY_SPACE, 0},
+    {0xB5, KEY_UP, 0},
+    {0xB6, KEY_DOWN, 0},
+    {0xB4, KEY_LEFT, 0},
+    {0xB7, KEY_RIGHT, 0},
+
+    {0x31, KEY_1, 0},
+    {0x32, KEY_2, 0},
+    {0x33, KEY_3, 0},
+    {0x34, KEY_4, 0},
+    {0x35, KEY_5, 0},
+    {0x36, KEY_6, 0},
+    {0x37, KEY_7, 0},
+    {0x38, KEY_8, 0},
+    {0x39, KEY_9, 0},
+    {0x30, KEY_0, 0},
+
+    // lower case mapping
+    
+    {0x61, KEY_A, 0},
+    {0x62, KEY_B, 0},
+    {0x63, KEY_C, 0},
+    {0x64, KEY_D, 0},
+    {0x65, KEY_E, 0},
+    {0x66, KEY_F, 0},
+    {0x67, KEY_G, 0},
+    {0x68, KEY_H, 0},
+    {0x69, KEY_I, 0},
+    {0x6A, KEY_J, 0},
+    {0x6B, KEY_K, 0},
+    {0x6C, KEY_L, 0},
+    {0x6D, KEY_M, 0},
+    {0x6E, KEY_N, 0},
+    {0x6F, KEY_O, 0},
+    {0x70, KEY_P, 0},
+    {0x71, KEY_Q, 0},
+    {0x72, KEY_R, 0},
+    {0x73, KEY_S, 0},
+    {0x74, KEY_T, 0},
+    {0x75, KEY_U, 0},
+    {0x76, KEY_V, 0},
+    {0x77, KEY_W, 0},
+    {0x78, KEY_X, 0},
+    {0x79, KEY_Y, 0},
+    {0x7A, KEY_Z, 0},
+
+    {0x2C,KEY_COMMA, 0},
+    {0x2E,KEY_DOT, 0},
+    
+    // symbol mapping
+    {0x21,KEY_1,CARDKB_MODIFIER_SHIFT},
+    {0x40,KEY_2,CARDKB_MODIFIER_SHIFT},
+    {0x23,KEY_3,CARDKB_MODIFIER_SHIFT},
+    {0x24,KEY_4,CARDKB_MODIFIER_SHIFT},
+    {0x25,KEY_5,CARDKB_MODIFIER_SHIFT},
+    {0x5E,KEY_6,CARDKB_MODIFIER_SHIFT},
+    {0x26,KEY_7,CARDKB_MODIFIER_SHIFT},
+    {0x2A,KEY_8,CARDKB_MODIFIER_SHIFT},
+    {0x28,KEY_9,CARDKB_MODIFIER_SHIFT},
+    {0x29,KEY_0,CARDKB_MODIFIER_SHIFT},
+    
+    {0x7B,KEY_LEFTBRACE,CARDKB_MODIFIER_SHIFT},
+    {0x7D,KEY_RIGHTBRACE,CARDKB_MODIFIER_SHIFT},
+    
+    {0x5B,KEY_LEFTBRACE,0},
+    {0x5D,KEY_RIGHTBRACE,0},
+    {0x2F,KEY_SLASH,0},
+    {0x5C,KEY_BACKSLASH,0},
+    {0x7C,KEY_BACKSLASH,CARDKB_MODIFIER_SHIFT},
+    {0x7E,KEY_GRAVE,CARDKB_MODIFIER_SHIFT},
+    {0x27,KEY_APOSTROPHE,0},
+    {0x22,KEY_APOSTROPHE,CARDKB_MODIFIER_SHIFT},
+
+    {0x3B,KEY_SEMICOLON,0},
+    {0x3A,KEY_SEMICOLON,CARDKB_MODIFIER_SHIFT},
+
+    {0x60,KEY_APOSTROPHE,0},
+    {0x2B,KEY_EQUAL,CARDKB_MODIFIER_SHIFT},
+    {0x2D,KEY_MINUS,0},
+    {0x5F,KEY_MINUS,CARDKB_MODIFIER_SHIFT},
+    {0x3D,KEY_EQUAL,0},
+    {0x3F,KEY_SLASH,CARDKB_MODIFIER_SHIFT},
+
+    {0x3C,KEY_COMMA, CARDKB_MODIFIER_SHIFT},
+    {0x3E,KEY_DOT, CARDKB_MODIFIER_SHIFT},
+
+    // upper case mapping
+    {0x41,KEY_A, CARDKB_MODIFIER_SHIFT},
+    {0x42,KEY_B, CARDKB_MODIFIER_SHIFT},
+    {0x43,KEY_C, CARDKB_MODIFIER_SHIFT},
+    {0x44,KEY_D, CARDKB_MODIFIER_SHIFT},
+    {0x45,KEY_E, CARDKB_MODIFIER_SHIFT},
+    {0x46,KEY_F, CARDKB_MODIFIER_SHIFT},
+    {0x47,KEY_G, CARDKB_MODIFIER_SHIFT},
+    {0x48,KEY_H, CARDKB_MODIFIER_SHIFT},
+    {0x49,KEY_I, CARDKB_MODIFIER_SHIFT},
+    {0x4A,KEY_J, CARDKB_MODIFIER_SHIFT},
+    {0x4B,KEY_K, CARDKB_MODIFIER_SHIFT},
+    {0x4C,KEY_L, CARDKB_MODIFIER_SHIFT},
+    {0x4D,KEY_M, CARDKB_MODIFIER_SHIFT},
+    {0x4E,KEY_N, CARDKB_MODIFIER_SHIFT},
+    {0x4F,KEY_O, CARDKB_MODIFIER_SHIFT},
+    {0x50,KEY_P, CARDKB_MODIFIER_SHIFT},
+    {0x51,KEY_Q, CARDKB_MODIFIER_SHIFT},
+    {0x52,KEY_R, CARDKB_MODIFIER_SHIFT},
+    {0x53,KEY_S, CARDKB_MODIFIER_SHIFT},
+    {0x54,KEY_T, CARDKB_MODIFIER_SHIFT},
+    {0x55,KEY_U, CARDKB_MODIFIER_SHIFT},
+    {0x56,KEY_V, CARDKB_MODIFIER_SHIFT},
+    {0x57,KEY_W, CARDKB_MODIFIER_SHIFT},
+    {0x58,KEY_X, CARDKB_MODIFIER_SHIFT},
+    {0x59,KEY_Y, CARDKB_MODIFIER_SHIFT},
+    {0x5A,KEY_Z, CARDKB_MODIFIER_SHIFT},
+
+    // fn-key mapping(to ctrl+keycode)
+
+    {0x80,KEY_ESC, CARDKB_MODIFIER_CTRL},
+    {0x81,KEY_1, CARDKB_MODIFIER_CTRL},
+    {0x82,KEY_2, CARDKB_MODIFIER_CTRL},
+    {0x83,KEY_3, CARDKB_MODIFIER_CTRL},
+    {0x84,KEY_4, CARDKB_MODIFIER_CTRL},
+    {0x85,KEY_5, CARDKB_MODIFIER_CTRL},
+    {0x86,KEY_6, CARDKB_MODIFIER_CTRL},
+    {0x87,KEY_7, CARDKB_MODIFIER_CTRL},
+    {0x88,KEY_8, CARDKB_MODIFIER_CTRL},
+    {0x89,KEY_9, CARDKB_MODIFIER_CTRL},
+    {0x8A,KEY_0, CARDKB_MODIFIER_CTRL},
+    {0x8B,KEY_BACKSPACE, CARDKB_MODIFIER_CTRL},
+    {0x8C,KEY_TAB, CARDKB_MODIFIER_CTRL},
+
+    {0x8D,KEY_Q,CARDKB_MODIFIER_CTRL},
+    {0x8E,KEY_W,CARDKB_MODIFIER_CTRL},
+    {0x8F,KEY_E,CARDKB_MODIFIER_CTRL},
+    {0x90,KEY_R,CARDKB_MODIFIER_CTRL},
+    {0x91,KEY_T,CARDKB_MODIFIER_CTRL},
+    {0x92,KEY_Y,CARDKB_MODIFIER_CTRL},
+    {0x93,KEY_U,CARDKB_MODIFIER_CTRL},
+    {0x94,KEY_I,CARDKB_MODIFIER_CTRL},
+    {0x95,KEY_O,CARDKB_MODIFIER_CTRL},
+    {0x96,KEY_P,CARDKB_MODIFIER_CTRL},
+    
+    {0x9A,KEY_A,CARDKB_MODIFIER_CTRL},
+    {0x9B,KEY_S,CARDKB_MODIFIER_CTRL},
+    {0x9C,KEY_D,CARDKB_MODIFIER_CTRL},
+    {0x9D,KEY_F,CARDKB_MODIFIER_CTRL},
+    {0x9E,KEY_G,CARDKB_MODIFIER_CTRL},
+    {0x9F,KEY_H,CARDKB_MODIFIER_CTRL},
+    {0xA0,KEY_J,CARDKB_MODIFIER_CTRL},
+    {0xA1,KEY_K,CARDKB_MODIFIER_CTRL},
+    {0xA2,KEY_L,CARDKB_MODIFIER_CTRL},
+    {0xA3,KEY_ENTER,CARDKB_MODIFIER_CTRL},
+
+    
+    {0xA6,KEY_Z,CARDKB_MODIFIER_CTRL},
+    {0xA7,KEY_X,CARDKB_MODIFIER_CTRL},
+    {0xA8,KEY_C,CARDKB_MODIFIER_CTRL},
+    {0xA9,KEY_V,CARDKB_MODIFIER_CTRL},
+    {0xAA,KEY_B,CARDKB_MODIFIER_CTRL},
+    {0xAB,KEY_N,CARDKB_MODIFIER_CTRL},
+    {0xAC,KEY_M,CARDKB_MODIFIER_CTRL},
+    
+    {0xAD,KEY_COMMA,CARDKB_MODIFIER_CTRL},
+    {0xAE,KEY_DOT,CARDKB_MODIFIER_CTRL},
+    {0xAF,KEY_SPACE,CARDKB_MODIFIER_CTRL},
+
+    {0x99,KEY_UP,CARDKB_MODIFIER_CTRL},
+    {0xA4,KEY_DOWN,CARDKB_MODIFIER_CTRL},
+    {0x98,KEY_LEFT,CARDKB_MODIFIER_CTRL},
+    {0xA5,KEY_RIGHT,CARDKB_MODIFIER_CTRL},
+
+};
+
+static void cardkb_report_key(struct cardkb_data *data, u8 code, int value){
+
+    int i;
+
+    SRGN_PRINTK("CardKB: report key: %d, value: %d\n", code, value);
+
+    for(i = 0; i < ARRAY_SIZE(cardkb_map); i++){
+        if(cardkb_map[i].code == code){
+            if(cardkb_map[i].modifier == 0){
+                input_report_key(data->input, cardkb_map[i].keycode, value);
+            }else if(cardkb_map[i].modifier == CARDKB_MODIFIER_CTRL){
+                input_report_key(data->input, KEY_LEFTCTRL, value);
+                input_report_key(data->input, cardkb_map[i].keycode, value);
+            }else if(cardkb_map[i].modifier == CARDKB_MODIFIER_SHIFT){
+                input_report_key(data->input, KEY_LEFTSHIFT, value);
+                input_report_key(data->input, cardkb_map[i].keycode, value);
+            }
+            input_sync(data->input);
+            return;
+        }
+    }
+
+    pr_info("CardKB: key not found: %d, value: %d\n", code, value);
+}
+
+
+static void cardkb_read(struct cardkb_data *data){
+    u8 code;
+    int len;
+
+    len = i2c_master_recv(data->client, &code, 1);
+    if(len <= 0){
+        return;
+    }
+    
+    if(data->last_code != 0){
+        cardkb_report_key(data, data->last_code, 0);
+    }
+
+    data->last_code = code;
+
+    if(code != 0){
+        cardkb_report_key(data, code, 1);
+    }
+}
+
+static void cardkb_work_func(struct work_struct *work)
+{
+	struct cardkb_data *data =
+		container_of(work, struct cardkb_data, dwork.work);
+
+	cardkb_read(data);
+	schedule_delayed_work(&data->dwork, msecs_to_jiffies(data->polling_interval));
+}
+
+static int cardkb_open(struct input_dev *dev)
+{
+	struct cardkb_data *data = input_get_drvdata(dev);
+
+    SRGN_PRINTK("cardkb open");
+
+	/* Get initial device state in case it has switches */
+	cardkb_read(data);
+
+    schedule_delayed_work(&data->dwork, msecs_to_jiffies(data->polling_interval));
+	return 0;
+}
+
+static void cardkb_close(struct input_dev *dev)
+{
+	struct cardkb_data *data = input_get_drvdata(dev);
+
+    SRGN_PRINTK("cardkb close");
+
+    cancel_delayed_work_sync(&data->dwork);
+
+}
+
+static int cardkb_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct cardkb_data *data;
+	struct input_dev *input;
+	int error;
+    int i;
+
+    struct device *dev = &client->dev;
+    struct device_node *np = dev->of_node;
+
+    u8 code;
+
+
+    SRGN_PRINTK("cardkb probed!");
+
+	/* Check functionality */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {
+		dev_err(&client->dev, "%s adapter not supported\n",
+			dev_driver_string(&client->adapter->dev));
+		return -ENODEV;
+	}
+
+    // try to read the first time to see if the cardkb is working
+    error = i2c_master_recv(client, &code, 1);
+    if(error < 0){
+        dev_err(&client->dev, "cardkb not found or not working: %d\n", error);
+        return -ENODEV;
+    }
+
+	data = kzalloc(sizeof(struct cardkb_data), GFP_KERNEL);
+	input = input_allocate_device();
+	if (!data || !input) {
+		error = -ENOMEM;
+		goto fail1;
+	}
+
+	data->client = client;
+	data->input = input;
+
+    error = of_property_read_u32(np, "polling-interval", &data->polling_interval);
+    if (error) {
+        dev_warn(dev, "Failed to read polling-interval: %d, using default: 100ms\n", error);
+        data->polling_interval = 100;
+    }
+
+
+	INIT_DELAYED_WORK(&data->dwork, cardkb_work_func);
+
+	input->phys = "cardkb/input0";
+	input->name = client->name;
+	input->dev.parent = &client->dev;
+
+	input->open = cardkb_open;
+	input->close = cardkb_close;
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0100;
+
+	__set_bit(EV_KEY, input->evbit);    
+    for (i = 0; i < ARRAY_SIZE(cardkb_map); i++){
+        __set_bit(cardkb_map[i].keycode, input->keybit);
+    }
+	__set_bit(KEY_LEFTCTRL, input->keybit);
+	__set_bit(KEY_LEFTSHIFT, input->keybit);
+
+
+	input_set_drvdata(input, data);
+
+	error = input_register_device(input);
+	if (error) {
+		dev_dbg(&client->dev,
+			"Unable to register input device, error: %d\n", error);
+		goto fail1;
+	}
+
+	i2c_set_clientdata(client, data);
+
+	return 0;
+
+fail1:
+	input_free_device(input);
+	kfree(data);
+	return error;
+}
+
+static int cardkb_remove(struct i2c_client *client)
+{
+	struct cardkb_data *data = i2c_get_clientdata(client);
+
+	input_unregister_device(data->input);
+	kfree(data);
+
+	return 0;
+}
+
+static const struct i2c_device_id cardkb_ids[] = { 
+    { "cardkb" ,32,},
+    {}
+};
+MODULE_DEVICE_TABLE(i2c, cardkb_ids);
+
+static const struct of_device_id cardkb_dt_ids[] = {
+	{
+		.compatible = "m5stack,cardkb",
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, cardkb_dt_ids);
+
+static struct i2c_driver cardkb_driver = {
+     .driver = {
+         .name	= "cardkb",
+         .of_match_table = cardkb_dt_ids,
+     },
+     .probe		= cardkb_probe,
+     .remove		= cardkb_remove,
+     .id_table	= cardkb_ids,
+ };
+
+static int __init cardkb_init(void)
+{
+	return i2c_add_driver(&cardkb_driver);
+}
+
+subsys_initcall(cardkb_init);
+
+static void __exit cardkb_exit(void)
+{
+	i2c_del_driver(&cardkb_driver);
+}
+module_exit(cardkb_exit);
+
+MODULE_AUTHOR("Shirgane Tsumugi");
+MODULE_DESCRIPTION("Keypad driver for M5Stack unit CardKB");
+MODULE_LICENSE("GPL");
--- a/drivers/staging/shirogane/Kconfig
+++ b/drivers/staging/shirogane/Kconfig
@@ -13,5 +13,20 @@
 	  A really simple driver to bit-bang the initialization sequence
 	  for ST7701-based LCDs over GPIOs, based on device tree settings.
 
+config SHIROGANE_KEYBOARD_CARDKB
+	tristate "M5Stack Cardkb Keypad Support"
+	depends on I2C
+	help
+		M5Stack Unit CardKB is a card-sized QWERTY 50-key
+		PCB matrix keyboard that uses ATMega8A as the encoding
+		MCU, with an output interface of I2C. It has one onboard
+		RGB-LED to indicate keyboard status.
+
+		This driver implements basic keypad functionality by
+		polling I2C bus, for M5Stack Unit CardKB V1.1.
+
+		To compile this driver as a module, choose M here: the
+		module will be called cardkb.
+
 
 endif # SHIROGANE
--- a/drivers/staging/shirogane/Makefile
+++ b/drivers/staging/shirogane/Makefile
@@ -1,2 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_SHIROGANE_SIMPLE_ST7701_INIT)	+= st7701init.o
+obj-$(CONFIG_SHIROGANE_KEYBOARD_CARDKB)	+= cardkb.o
